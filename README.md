# Лабораторная работа №9: Оптимизация образов контейнеров

## Цель работы

Ознакомиться с методами оптимизации Docker-образов: удаление временных файлов, уменьшение слоёв, выбор минимального основного образа, перепаковка образов.

---

## Задание

Сравнить различные методы оптимизации образов:

- Удаление неиспользуемых зависимостей и временных файлов
- Уменьшение количества слоев
- Минимальный базовый образ
- Перепаковка образа
- Использование всех методов

---

## Ход работы

### 1. Клонирован пустой Git-репозиторий `containers09`

```bash
git clone git@github.com:iurii1801/containers09.git
```

![image](https://i.imgur.com/euS4Qhr.png)

### 2. В папке `containers09` создана папка `site` и перемещены в неё файлы сайта (`html`, `css`, `js`)

![image](https://i.imgur.com/qrgNqqI.png)

![image](https://i.imgur.com/gkRVbnV.png)

### 3. Создание и наполнение файла `Dockerfile.raw` с инструкциями для базовой сборки контейнера `Nginx` без оптимизации

- **Создан `Dockerfile.raw`:**

```powershell
New-Item -Name "Dockerfile.raw" -ItemType "File"
```

![image](https://i.imgur.com/89ZcGty.png)

Это создаёт пустой файл `Dockerfile.raw` в директории `containers09`. Он будет содержать инструкции для базовой сборки `Docker-образа` с `Nginx` на основе `Ubuntu` без какой-либо оптимизации.

- **Содержимое:**

```dockerfile
# create from ubuntu image
FROM ubuntu:latest

# update system
RUN apt-get update && apt-get upgrade -y

# install nginx
RUN apt-get install -y nginx

# copy site
COPY site /var/www/html

# expose port 80
EXPOSE 80

# run nginx
CMD ["nginx", "-g", "daemon off;"]
```

![image](https://i.imgur.com/vJDh81a.png)

Файл `Dockerfile.raw` представляет собой базовую версию инструкции сборки Docker-образа, основанную на полном образе `ubuntu:latest`. В этом Dockerfile все шаги выполняются отдельно: сначала происходит обновление системы, затем установка веб-сервера Nginx, далее в контейнер копируются файлы сайта из локальной директории `site/`, открывается 80-й порт, и указывается команда запуска Nginx. Данный подход логически разделяет этапы, что может быть удобно при отладке, но в то же время создаёт множество промежуточных слоёв и не удаляет кэш или временные файлы. Это приводит к тому, что финальный образ получается большим по размеру. Именно этот Dockerfile используется в лабораторной работе как отправная точка для анализа и последующей оптимизации.

- **Сборка `Docker-образа mynginx:raw` из файла `Dockerfile.raw`**

```powershell
docker image build -t mynginx:raw -f Dockerfile.raw .
```

![image](https://i.imgur.com/6np9as3.png)

- **Проверка размера образа `mynginx:raw` после сборки**

```powershell
docker image list
```

![image](https://i.imgur.com/UgNxd9K.png)

В таблице указаны их теги (`TAG`), идентификаторы (`IMAGE ID`), время создания (`CREATED`) и размер (`SIZE`).

В верхней строке видно, что образ `mynginx` с тегом `raw` был создан недавно (36 seconds ago) и занимает 241MB. Это подтверждает, что не оптимизированный образ достаточно тяжёлый, поскольку:

1. использован базовый образ `ubuntu:latest`

2. каждая команда создаёт отдельный слой

3. не были удалены временные файлы и кэш `apt`

Эта информация послужит отправной точкой для сравнения с оптимизированными версиями образов, создаваемыми в следующих шагах.

### 4. Создание файла `Dockerfile.clean` для образа с очисткой кэша

```powershell
New-Item -Name "Dockerfile.clean" -ItemType "File"
```

![image](https://i.imgur.com/Lv3Pof4.png)

Эта команда создаёт новый пустой файл `Dockerfile.clean` в директории `containers09`. В дальнейшем в этот файл будут добавлены инструкции для сборки Docker-образа, аналогичного raw, но с добавлением команды очистки кэша и временных файлов, чтобы уменьшить размер итогового образа.

Этот шаг закладывает основу для первой стадии оптимизации Docker-образа.

- **Содержимое:**

```powershell
# create from ubuntu image
FROM ubuntu:latest

# update system
RUN apt-get update && apt-get upgrade -y

# install nginx
RUN apt-get install -y nginx

# remove apt cache
RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

# copy site
COPY site /var/www/html

# expose port 80
EXPOSE 80

# run nginx
CMD ["nginx", "-g", "daemon off;"]
```

![image](https://i.imgur.com/eRw0Pi4.png)

`Dockerfile.clean` представляет собой улучшенную версию предыдущего файла. В нём добавлена очистка кэша менеджера пакетов `apt`, а также удаление временных директорий после завершения установки. Это достигается добавлением отдельной инструкции `RUN apt-get clean && rm -rf ...`. Однако, несмотря на наличие этих команд, оптимизация в этом Dockerfile неэффективна. Причина в том, что каждая команда RUN создаёт новый слой, и если очистка выполняется в отдельной инструкции, то кэшированные данные из предыдущих слоёв всё равно сохраняются в истории сборки образа. Таким образом, даже при удалении временных файлов, размер итогового образа почти не уменьшается. Этот Dockerfile используется для иллюстрации важности правильного размещения команд очистки внутри одной инструкции.

- **Сборка оптимизированного образа `mynginx:clean` с удалением кэша**

```powershell
docker image build -t mynginx:clean -f Dockerfile.clean .
```

![image](https://i.imgur.com/xN2qpKl.png)

- **Сравнение размеров образов: `raw` и `clean`**

```powershell
docker image list
```

![image](https://i.imgur.com/RIOG6yJ.png)

- На этом этапе сравниваются размеры исходного (`mynginx:raw`) и оптимизированного (`mynginx:clean`) образов.

Что видно:

1. `mynginx:raw` и `mynginx:clean` оба занимают по 241MB, несмотря на то что во втором Dockerfile была добавлена очистка кэша (apt-get clean, rm -rf /tmp/* и др.).

2. Это подтверждает важный вывод: если очистка выполняется в отдельной инструкции RUN, то размер образа почти не изменяется, так как предыдущие слои (включая кэш) всё равно остаются в истории сборки.

***Вывод:***
Для эффективной оптимизации необходимо объединять очистку с установкой пакетов в одну инструкцию RUN, как это будет сделано в следующем Dockerfile (few).

## Уменьшение количества слоёв

### 5. Создание файла `Dockerfile.few`

```powershell
New-Item -Name "Dockerfile.few" -ItemType "File"
```

![image](https://i.imgur.com/3BeYdxp.png)

Этот файл предназначен для хранения Docker-инструкций сборки оптимизированного образа, в котором установка пакетов и удаление временных данных выполняются в одной команде `RUN`. Это позволяет сократить количество слоёв образа и уменьшить его итоговый размер, в отличие от предыдущего Dockerfile с отдельными инструкциями.

- **Содержимое:**

```powershell
# create from ubuntu image
FROM ubuntu:latest

# update system, install nginx, clean everything — all in one RUN
RUN apt-get update && apt-get upgrade -y && \
    apt-get install -y nginx && \
    apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

# copy site
COPY site /var/www/html

# expose port 80
EXPOSE 80

# run nginx
CMD ["nginx", "-g", "daemon off;"]
```

![image](https://i.imgur.com/uzqucJe.png)

`Dockerfile.few` устраняет недостаток предыдущей версии. Все команды, связанные с обновлением системы, установкой Nginx и последующей очисткой, объединены в одну инструкцию `RUN`. Это позволяет Docker’у сохранить в образе только конечное состояние файловой системы, без промежуточных слоёв, содержащих временные и ненужные файлы. Такой подход значительно уменьшает итоговый размер образа. В лабораторной работе этот Dockerfile демонстрирует эффективную практику оптимизации путём сокращения количества слоёв и удаления кэша непосредственно в процессе установки. Это уже первый шаг к созданию действительно минимального и производительного контейнера.

- **Сборка образа `mynginx:few` из `Dockerfile.few`**

```powershell
docker image build -t mynginx:few -f Dockerfile.few .
```

![image](https://i.imgur.com/FndaxVZ.png)

- **Сравнение размеров образов после сборки `mynginx:few`**

```powershell
docker image list
```

![image](https://i.imgur.com/IXPKdp7.png)

Список отображает все образы, хранящиеся в локальном реестре `Docker`. Здесь видны три ключевых образа проекта:

`mynginx:raw` — 241MB
Базовый образ без оптимизации, построен на `ubuntu:latest` с множеством отдельных слоёв и без очистки кэша.

`mynginx:clean` — 241MB
Несмотря на добавленную очистку `apt-get clean` и `rm -rf`, она выполнена в отдельной инструкции RUN, и кэш сохраняется в предыдущих слоях.

`mynginx:few` — 192MB
Здесь команды установки и очистки объединены в один `RUN`. Это позволяет `Docker` выбросить промежуточные данные, сократив размер почти на 50MB.

***Вывод:*** 
Реальная экономия достигается только в том случае, если установка и удаление лишних файлов выполняются в одной инструкции `RUN`, иначе ненужные данные всё равно сохраняются внутри образа в истории слоёв.

## Минимальный базовый образ

### 6. Создание минимального `Dockerfile` на базе `Alpine`: `Dockerfile.alpine`

```powershell
New-Item -Name "Dockerfile.alpine" -ItemType "File"
```

![image](https://i.imgur.com/jKRlKS5.png)

Файл будет использоваться для сборки образа на основе минималистичного дистрибутива `Alpine Linux`, что значительно уменьшает итоговый размер образа.

Цель: использовать `Alpine` в качестве базового образа вместо `Ubuntu` для дальнейшей оптимизации.

Далее в этот файл будет добавлен код с инструкциями для установки nginx, копирования сайта и запуска сервера.

- **Содержимое:**

```powershell
# create from alpine image
FROM alpine:latest

# update system
RUN apk update && apk upgrade

# install nginx
RUN apk add nginx

# copy site
COPY site /var/www/html

# expose port 80
EXPOSE 80

# run nginx
CMD ["nginx", "-g", "daemon off;"]
```

![image](https://i.imgur.com/xaIYU4B.png)

`Dockerfile.alpine` строится на минималистичном базовом образе `alpine:latest`, который изначально весит менее 10MB. В нём используется пакетный менеджер `apk`, характерный для Alpine Linux. Все действия аналогичны предыдущим версиям: обновление системы, установка Nginx, копирование сайта и запуск веб-сервера. Однако сама по себе замена базового образа уже даёт значительный выигрыш в размере — итоговый образ становится в разы меньше. Несмотря на это, команды по очистке временных файлов здесь отсутствуют, и установка пакетов разбита на отдельные инструкции. Такой Dockerfile даёт хорошее представление о том, насколько важен выбор базового образа при оптимизации, даже без дополнительных действий по объединению слоёв.

- **Сборка оптимизированного образа `mynginx:alpine` из `Dockerfile.alpine`**

```powershell
docker image build -t mynginx:alpine -f Dockerfile.alpine .
```

![image](https://i.imgur.com/DKFNljj.png)

- **Сравнение размеров образов: `raw`, `clean`, `few`, `alpine`**

```powershell
docker image list
```

![image](https://i.imgur.com/aGCfwBc.png)

Команда отображает все локальные Docker-образы, включая их размер. По выведенным данным видно, что изначальный образ `mynginx:raw` весит 241MB, и даже после очистки кэша (`mynginx:clean`) размер не изменился. Это связано с тем, что очистка выполнялась в отдельном слое. Образ `mynginx:few`, где все команды объединены в одну инструкцию `RUN`, уже весит меньше — 192MB. Наилучший результат показывает `mynginx:alpine` — всего 79.3MB благодаря использованию минимального базового образа. Это подтверждает, что для эффективной оптимизации важно объединять команды и использовать лёгкие образы, особенно в продакшене.

### 7. Перепаковка образа

1. Создание временного контейнера из образа `mynginx:raw`:

```bash
docker container create --name mynginx mynginx:raw
```

Контейнер `mynginx` создаётся из образа, но пока не запускается.

2. Экспорт контейнера и импорт как новый образ `mynginx:repack`:

```bash
docker container export mynginx | docker image import - mynginx:repack
```

Контейнер `mynginx` экспортируется в виде потока данных и тут же импортируется обратно как новый оптимизированный образ `mynginx:repack`. Это удаляет историю слоёв и метаданные, тем самым уменьшает размер образа.

3. Удаление временного контейнера:

```bash
docker container rm mynginx
```

После перепаковки контейнер больше не нужен и удаляется.

![image](https://i.imgur.com/g5vDZqY.png)

- **Сравнение размеров образов: `raw`, `clean`, `few`, `alpine`**

```powershell
docker image list
```

![image](https://i.imgur.com/6NoY7Qw.png)

Финальный список Docker-образов, созданных в процессе лабораторной работы. Видно, как разные методы оптимизации влияют на размер. Образ `mynginx:raw` собран без оптимизации и занимает 241MB. `mynginx:clean` с очисткой кэша в отдельном слое остался того же размера, поскольку предыдущие слои сохраняются. Объединение команд в `mynginx:few` дало эффект — размер уменьшился до 192MB. Наиболее компактным стал `mynginx:alpine` — всего 79.3MB, благодаря использованию минимального базового образа `Alpine`. Перепаковка `mynginx:repack` убрала метаданные и снизила размер до 201MB, но всё ещё уступает варианту на `Alpine`. Таким образом, оптимизация эффективна при правильной структуре `Dockerfile` и выборе базового образа.

### 8. Создание финального `Dockerfile` для минимального образа (`Dockerfile.min`)

```powershell
New-Item -Name "Dockerfile.min" -ItemType "File"
```

![image](https://i.imgur.com/IBjewoA.png)

Создание нового файла с именем `Dockerfile.min` в директории `containers09` с помощью команды PowerShell New-Item. Этот файл будет использоваться для финальной, максимально оптимизированной версии Dockerfile. В этом варианте будет объединена установка пакетов и очистка, а также использован минимальный базовый образ `alpine`. Это завершает серию оптимизаций, направленных на снижение размера контейнеров.

- **Содержимое:**

```powershell
# create from alpine image
FROM alpine:latest

# update system, install nginx and clean cache — всё в одном RUN
RUN apk update && apk upgrade && \
    apk add nginx && \
    rm -rf /var/cache/apk/*

# copy site
COPY site /var/www/html

# expose port 80
EXPOSE 80

# run nginx
CMD ["nginx", "-g", "daemon off;"]
```

![image](https://i.imgur.com/ONBDLwc.png)

На данном шаге был создан и заполнен файл `Dockerfile.min`, который реализует максимально оптимизированный способ сборки контейнера. Внутри используется минималистичный базовый образ `alpine:latest`, установка Nginx, обновление системы и очистка кеша объединены в один слой через одну команду `RUN`, что позволяет сократить финальный размер образа. Это делает `Dockerfile.min` самым эффективным вариантом среди всех рассмотренных.

## Запуск и тестирование

### 9. Сборка минимизированного образа с полной оптимизацией

```powershell
docker image build -t mynginx:minx -f Dockerfile.min .
```

![image](https://i.imgur.com/ftKk8Ca.png)

На этом этапе выполняется сборка оптимизированного Docker-образа `mynginx:minx` с использованием файла `Dockerfile.min`. Команда `docker image build -t mynginx:minx -f Dockerfile.min .` инициирует процесс сборки, где задействуется образ `alpine`, установка `nginx` и очистка кэша объединены в один слой. Это позволяет достичь минимального размера итогового образа. Сборка завершается успешно, и образ получает тег `mynginx:minx`.

### 10. Перепаковка финального образа mynginx:minx

```bash
docker container create --name mynginx mynginx:minx
docker container export mynginx -o mynginx_min.tar
docker image import mynginx_min.tar mynginx:min
docker container rm mynginx
```

Этот этап позволяет перепаковать контейнер в новый образ, удаляя историю слоёв и метаданные. Итог — ещё более лёгкий и чистый образ `mynginx:min`.

![image](https://i.imgur.com/Z2ctN5C.png)

## Запуск и тестирование

- **Проверка размеров образов**

```powershell
docker image list
```

![image](https://i.imgur.com/i3QP3Wu.png)

На этом скриншоте снова показан вывод команды `docker image list`, но уже после всех этапов оптимизации. Он демонстрирует финальный результат по всем версиям образов: от `raw` до `min`. Мы видим, что образ `mynginx:min` занимает всего **76.7MB**, в то время как начальный `mynginx:raw` — **241MB**. Это подтверждает, что последовательная оптимизация (объединение RUN, использование `alpine`, очистка кэша и перепаковка) значительно снижает размер образа.

---

## Сравнительная таблица размеров образов

```markdown
| Название образа     | Размер     | Комментарий                                     |
|---------------------|------------|-------------------------------------------------|
| `mynginx:raw`       | 241MB      | Исходный образ без оптимизации                  |
| `mynginx:clean`     | 241MB      | Очистка в отдельном слое — без эффекта          |
| `mynginx:few`       | 192MB      | Объединение в один слой уменьшило размер        |
| `mynginx:alpine`    | 79.3MB     | Использование минимального базового образа      |
| `mynginx:repack`    | 201MB      | Перепаковка без изменения функциональности      |
| `mynginx:min`       | 76.7MB     | Максимальная оптимизация — alpine + очистка     |
```

---

## Ответы на вопросы

### **Какой метод оптимизации образов вы считаете наиболее эффективным?**  

Наиболее эффективным методом является сочетание **использования минимального базового образа** (например, `alpine`) и **объединения всех операций в одну инструкцию `RUN`**. Такой подход не только значительно снижает общий размер образа, но и исключает накопление временных файлов и кэша в промежуточных слоях. Использование `alpine` даёт стартовую лёгкую платформу (менее 10MB), а объединение шагов в один `RUN` обеспечивает, что в финальный слой попадёт только нужное состояние файловой системы. Это особенно важно для продакшн-приложений, где вес контейнера влияет на скорость развёртывания, загрузки и масштабирования.

### **Почему очистка кэша пакетов в отдельном слое не уменьшает размер образа?**

Docker работает послойно: каждая инструкция `RUN`, `COPY`, `ADD` создаёт новый слой, и все данные, записанные на этом этапе, сохраняются. Если установка пакетов и их кэш происходят в одном слое, а очистка — в следующем, то Docker всё равно сохраняет содержимое предыдущего слоя (с кэшем), даже если оно было "удалено" в последующем. То есть, файлы удаляются из финального состояния контейнера, но физически остаются в истории слоёв, увеличивая общий размер. Только если установка и очистка выполняются в одной команде `RUN`, Docker сохраняет только итог без кэша, что позволяет действительно сократить размер.

### **Что такое перепаковка образа?**  

Перепаковка — это процесс удаления истории слоёв и метаданных из Docker-образа. Он осуществляется через экспорт контейнера в архив (`docker container export`) и повторный импорт этого архива как нового образа (`docker image import`). В результате создаётся "плоский" образ без промежуточных слоёв, что снижает его размер. Хотя такой подход немного ограничивает прозрачность изменений (например, нельзя увидеть, какие именно команды использовались), он отлично подходит для финальной сборки минималистичных и чистых образов, особенно когда важна лёгкость и скорость доставки.

---

## Вывод

В ходе лабораторной работы были изучены и применены ключевые методы оптимизации Docker-образов. Базовый образ `mynginx:raw`, собранный на `ubuntu`, оказался самым тяжёлым — 241MB. Попытка очистки кэша в отдельной инструкции `RUN` не дала результата, так как данные сохранялись в предыдущих слоях. Реальное уменьшение объёма стало возможным только после объединения всех шагов установки и очистки в одну инструкцию — образ `mynginx:few` уменьшился до 192MB.

Наибольшую эффективность показал переход на базу `alpine` и объединение всех операций в `Dockerfile.min`, что позволило получить итоговый образ `mynginx:min` весом всего 76.7MB после перепаковки. Работа продемонстрировала, что минимизация числа слоёв, правильное размещение инструкций и выбор лёгкой базы критически важны для создания компактных и производительных контейнеров.

---

## Библиография

1. [Официальная документация Docker](https://docs.docker.com/)  
2. [Документация Alpine Linux](https://alpinelinux.org/docs/)  
3. [DockerHub: nginx (официальный образ)](https://hub.docker.com/_/nginx)  
4. [Dockerfile Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)  
5. [docker image import / export](https://docs.docker.com/engine/reference/commandline/image_import/)  
6. [Docker Storage and Layers](https://docs.docker.com/storage/storagedriver/)  
7. [Оптимизация контейнеров Docker](https://docs.docker.com/config/containers/resource_constraints/)  
8. [Официальная документация PowerShell](https://learn.microsoft.com/en-us/powershell/)
